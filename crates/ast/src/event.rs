use crate::{SyntaxKind, SyntaxNode};
use rowan::GreenNodeBuilder;
use text_size::TextRange;

/// Represents an event generated by a parser.
#[derive(Debug, PartialEq, Eq)]
pub enum Event {
    /// Represents the start of an AST node.
    /// StartNode needs to be paired with a corresponding FinishNode later.
    StartNode {
        /// The kind of node to start.
        kind: SyntaxKind,

        /// Marks a later node that should be the parent of this node.
        parent: usize,
    },

    /// Represents the end of an AST node.
    /// FinishNode needs to correspond to a previous StartNode event.
    FinishNode,

    /// Represents a token of parsed text.
    Token {
        /// The kind of token.
        kind: SyntaxKind,

        /// The range this token takes in the input file.
        range: TextRange,
    },

    /// Represents an error while parsing.
    /// The AST crate does no do any error handling and will just ignore this type of event.
    Error {
        /// What was expected.
        expected: &'static str,

        /// Range in the input file that caused the error.
        range: TextRange,
    },

    /// A stubbed out event that does nothing.
    Stub,
}

/// Creates a [`SyntaxNode`] from a list of events.
/// The resulting node is untyped and the user of this method responsible for creating the correct AST type.
///
/// ## Panics
///
/// This method will panic if [`Event::StartNode`] and [`Event::FinishNode`] do not match up.
/// It will also panic if not exactly one root node is created,
/// meaning the first event has to be [`Event::StartNode`] and last event has to be [`Event::FinishNode`].
pub fn build_from_events(mut events: Vec<Event>, text: &str) -> SyntaxNode {
    let mut builder = GreenNodeBuilder::new();

    for idx in 0..events.len() - 1 {
        process_event(&mut events, text, &mut builder, idx);
    }

    if let Some(Event::FinishNode) = events.last() {
        SyntaxNode::new_root(builder.finish())
    } else {
        panic!("Events have to finish with a FinishNode event");
    }
}

fn process_event(events: &mut [Event], text: &str, builder: &mut GreenNodeBuilder, idx: usize) {
    match events[idx] {
        Event::StartNode { kind, parent } => {
            if parent > 0 {
                if let Event::StartNode { .. } = &events[idx + parent] {
                    process_event(events, text, builder, idx + parent);
                    events[idx + parent] = Event::Stub;
                }
            }

            builder.start_node(kind.into());
        }
        Event::FinishNode => builder.finish_node(),
        Event::Token { kind, range } => builder.token(kind.into(), &text[range]),
        Event::Error { .. } | Event::Stub => {}
    }
}
